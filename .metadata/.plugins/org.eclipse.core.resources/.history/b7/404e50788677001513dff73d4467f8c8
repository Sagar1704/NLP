package sea.nlp.pos;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.TreeSet;

import sea.nlp.comparator.ErrorComparator;

public class POS {
	private TreeSet<WordTagsCount> words;

	//that
	private ArrayList<String> thatPreviousIN1 = new ArrayList<String>();
	private ArrayList<String> thatNextIN1 = new ArrayList<String>();
	
	private ArrayList<String> thatPreviousIN2 = new ArrayList<String>();
	private ArrayList<String> thatNextIN2 = new ArrayList<String>();
	
	private ArrayList<String> thatPreviousWDT1 = new ArrayList<String>();
	private ArrayList<String> thatNextWDT1 = new ArrayList<String>();
	
	private ArrayList<String> thatPreviousWDT2 = new ArrayList<String>();
	private ArrayList<String> thatNextWDT2 = new ArrayList<String>();
	
	private ArrayList<String> thatPreviousDT1 = new ArrayList<String>();
	private ArrayList<String> thatNextDT1 = new ArrayList<String>();
	//
	
	//have
	private ArrayList<String> havePreviousVBP1 = new ArrayList<String>();
	private ArrayList<String> haveNextVBP1 = new ArrayList<String>();
	
	private ArrayList<String> havePreviousVBP2 = new ArrayList<String>();
	private ArrayList<String> haveNextVBP2 = new ArrayList<String>();
	
	private ArrayList<String> havePreviousVB1 = new ArrayList<String>();
	private ArrayList<String> haveNextVB1 = new ArrayList<String>();
	
	private ArrayList<String> havePreviousVB2 = new ArrayList<String>();
	private ArrayList<String> haveNextVB2 = new ArrayList<String>();
	//
	
	
	
	public POS() {
		this.words = new TreeSet<WordTagsCount>(new ErrorComparator());
		//that(IN)
		thatPreviousIN1.add("NN");
		thatPreviousIN1.add("VBD");
		thatPreviousIN1.add("");
		thatNextIN1.add("PRP");

		thatPreviousIN2.add("NN");
		thatPreviousIN2.add("VBD");
		thatPreviousIN2.add("VBZ");
		thatPreviousIN2.add("NNS");
		thatPreviousIN2.add("VB");
		thatPreviousIN2.add("");
		thatNextIN2.add("DT");
		
		//that(WDT)
		thatPreviousWDT1.add("NN");
		thatNextWDT1.add("VBZ");
		thatNextWDT1.add("VBD");
		thatNextWDT1.add("MD");
		
		thatPreviousWDT2.add("NNS");
		thatNextWDT2.add("VBP");
		thatNextWDT2.add("MD");
		thatNextWDT2.add("VBD");
		thatNextWDT2.add("VBZ");
		
		//that(DT)
		thatPreviousDT1.add("IN");
		thatPreviousDT1.add("CC");
		thatPreviousDT1.add("VBG");
		thatPreviousDT1.add("VBD");
		thatPreviousDT1.add("TO");
		thatPreviousDT1.add("VBP");
		thatNextDT1.add("NN");
		

	}

	public TreeSet<WordTagsCount> getWords() {
		return words;
	}

	public void setWords(TreeSet<WordTagsCount> words) {
		this.words = words;
	}

	public void addWord(String word, String tag) {
		WordTagsCount wordTag = new WordTagsCount(word, tag);

		for (Iterator<WordTagsCount> treeIterator = words.iterator(); treeIterator.hasNext();) {
			WordTagsCount wordTagsCount = (WordTagsCount) treeIterator.next();
			if (wordTagsCount.equals(wordTag)) {
				wordTag.setWordCounter(wordTagsCount.getWordCounter() + 1);
				wordTagsCount.addTag(tag);
				wordTag.setTags(wordTagsCount.getTags());
				treeIterator.remove();
				break;
			}
		}
		words.add(wordTag);
	}

	public String getCorrectTag(String word) {
		for (Iterator<WordTagsCount> treeIterator = words.iterator(); treeIterator.hasNext();) {
			WordTagsCount wordTagsCount = (WordTagsCount) treeIterator.next();
			if (wordTagsCount.equals(new WordTagsCount(word))) {
				return wordTagsCount.getCorrectTag();
			}
		}
		return "";
	}

	public String getCorrectTagUsingRules(String word, String previousTag, String nextTag) {
		if(word.equals("that")) {
			
		} else if(word.equals("have")) {
			
		} else if(word.equals("more")) {
			
		} else if(word.equals("'s")) {
			
		} else if(word.equals("plans")) {
			
		}
		
		return "";
	}

	public void incrementErrorCounter(String word) {
		WordTagsCount wordTag = new WordTagsCount(word);
		for (Iterator<WordTagsCount> treeIterator = words.iterator(); treeIterator.hasNext();) {
			WordTagsCount wordTagsCount = (WordTagsCount) treeIterator.next();
			if (wordTagsCount.equals(new WordTagsCount(word))) {
				wordTag.setErrorCounter(wordTagsCount.getErrorCounter() + 1);
				wordTag.setWordCounter(wordTagsCount.getWordCounter());
				wordTag.setTags(wordTagsCount.getTags());
				treeIterator.remove();
				break;
			}
		}
		words.add(wordTag);
	}

	public int getErrorCount() {
		int count = 0;
		for (WordTagsCount wordTagsCount : words) {
			count += wordTagsCount.getErrorCounter();
		}
		return count;
	}

	public int getWordCount() {
		int count = 0;
		for (WordTagsCount wordTagsCount : words) {
			count += wordTagsCount.getWordCounter();
		}
		return count;
	}

	public TreeSet<WordTagsCount> getTopErroneousWords(int top) {
		TreeSet<WordTagsCount> wordErrors = new TreeSet<WordTagsCount>(new ErrorComparator());
		int size = (top < words.size() ? top : words.size());
		for (WordTagsCount wordError : words) {
			if (size == 0)
				break;
			wordErrors.add(wordError);
			size--;
		}

		return wordErrors;
	}

	public void updateWordContext(String word, String tag, String previousTag, String nextTag) {
		WordTagsCount wordTag = new WordTagsCount(word, tag);

		for (Iterator<WordTagsCount> treeIterator = words.iterator(); treeIterator.hasNext();) {
			WordTagsCount wordTagsCount = (WordTagsCount) treeIterator.next();
			if (wordTagsCount.equals(wordTag)) {
				wordTagsCount.updateTagContext(tag, previousTag, nextTag);
				break;
			}
		}
	}

}
